// Advanced scenarios and interaction tests for OpenTelemetry Span Context

// Test context creation with various ID combinations
test "context_with_identical_trace_and_span_prefixes" {
  let trace_id = [0xAB, 0xCD, 0xEF, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d]
  let span_id = [0xAB, 0xCD, 0xEF, 0x01, 0x02, 0x03, 0x04, 0x05]
  let ctx = span_context(trace_id, span_id, 1)
  assert_true(ctx.is_valid())
  assert_true(ctx.is_sampled())
}

test "context_with_complementary_ids" {
  let trace_id = [0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00]
  let span_id = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "context_with_mirror_pattern_ids" {
  let trace_id = [0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0xF0, 0xED, 0xCB, 0xA9, 0x87, 0x65, 0x43, 0x21]
  let span_id = [0x12, 0x34, 0x56, 0x78, 0x87, 0x65, 0x43, 0x21]
  let ctx = span_context(trace_id, span_id, 1)
  assert_true(ctx.is_valid())
}

// Test hex encoding for special patterns
test "hex_full_spectrum_single_nibble" {
  let bytes = [0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9A, 0xAB, 0xBC, 0xCD, 0xDE, 0xEF, 0xF0]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "0112233445566778899aabbccddeeff0")
}

test "hex_nibble_boundaries_low" {
  let bytes = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "0001020304050607")
}

test "hex_nibble_boundaries_high" {
  let bytes = [0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "08090a0b0c0d0e0f")
}

test "hex_upper_nibble_variations" {
  let bytes = [0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "1020304050607080")
}

test "hex_lower_nibble_variations" {
  let bytes = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "0102030405060708")
}

// Test is_zero with various patterns
test "is_zero_with_negative_values" {
  let bytes = [-1, -2, -3]
  assert_false(is_zero(bytes))
}

test "is_zero_with_large_values" {
  let bytes = [256, 512, 1024]
  assert_false(is_zero(bytes))
}

test "is_zero_mixed_zeros_and_nonzeros" {
  let bytes = [0, 0, 1, 0, 0]
  assert_false(is_zero(bytes))
}

test "is_zero_very_long_zero_array" {
  let bytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  assert_true(is_zero(bytes))
}

// Test trace flags with comprehensive bit patterns
test "trace_flags_all_odd_bits_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x55)
  assert_true(ctx.is_sampled())
}

test "trace_flags_all_even_bits_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0xAA)
  assert_false(ctx.is_sampled())
}

test "trace_flags_lower_nibble_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x0F)
  assert_true(ctx.is_sampled())
}

test "trace_flags_upper_nibble_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0xF0)
  assert_false(ctx.is_sampled())
}

// Test complex validation scenarios
test "context_validation_with_near_zero_trace_id" {
  let trace_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
  let span_id = [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "context_validation_with_near_zero_span_id" {
  let trace_id = [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
  let span_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

// Test hex encoding edge cases with specific byte combinations
test "hex_byte_with_zero_high_nibble" {
  let bytes = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "0102030405060708090a0b0c0d0e0f")
}

test "hex_byte_with_zero_low_nibble" {
  let bytes = [0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "102030405060708090a0b0c0d0e0f0")
}

test "hex_mixed_high_low_nibbles" {
  let bytes = [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "112233445566778899aabbccddeeff")
}

// Test context properties consistency
test "context_properties_remain_consistent_after_creation" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18]
  let ctx = span_context(trace_id, span_id, 1)
  
  assert_true(ctx.is_valid())
  assert_true(ctx.is_sampled())
  assert_eq(ctx.trace_id_hex(), "0102030405060708090a0b0c0d0e0f10")
  assert_eq(ctx.span_id_hex(), "1112131415161718")
}

test "invalid_context_properties_remain_consistent" {
  let ctx = invalid_span_context()
  
  assert_false(ctx.is_valid())
  assert_false(ctx.is_sampled())
  assert_eq(ctx.trace_flags, 0)
}

// Test boundary conditions for array lengths
test "trace_id_length_15_is_invalid" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

test "trace_id_length_17_is_invalid" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

test "span_id_length_7_is_invalid" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

test "span_id_length_9_is_invalid" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

// Test special numeric patterns
test "trace_id_fibonacci_like_pattern" {
  let trace_id = [0x01, 0x01, 0x02, 0x03, 0x05, 0x08, 0x0D, 0x15, 0x22, 0x37, 0x59, 0x01, 0x01, 0x01, 0x01, 0x01]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "span_id_prime_like_pattern" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D, 0x11, 0x13]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

// Test context with specific hex patterns
test "context_creates_readable_hex_pattern" {
  let trace_id = [0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE, 0xBA, 0xBE, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0]
  let span_id = [0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE, 0xBA, 0xBE]
  let ctx = span_context(trace_id, span_id, 1)
  assert_true(ctx.is_valid())
  assert_eq(ctx.span_id_hex(), "deadbeefcafebabe")
}

test "context_with_ascii_like_values" {
  let trace_id = [0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50]
  let span_id = [0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

// Test byte_to_hex_char edge cases
test "byte_to_hex_char_values_above_15" {
  assert_eq(byte_to_hex_char(17), "0")
  assert_eq(byte_to_hex_char(100), "0")
  assert_eq(byte_to_hex_char(128), "0")
}

// Test combinations of sampled and not sampled
test "multiple_contexts_different_sampling" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id1 = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let span_id2 = [0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18]
  
  let ctx1 = span_context(trace_id, span_id1, 1)
  let ctx2 = span_context(trace_id, span_id2, 0)
  
  assert_true(ctx1.is_sampled())
  assert_false(ctx2.is_sampled())
}

// Test is_zero with various array sizes
test "is_zero_array_size_1_zero" {
  assert_true(is_zero([0]))
}

test "is_zero_array_size_2_zeros" {
  assert_true(is_zero([0, 0]))
}

test "is_zero_array_size_8_zeros" {
  assert_true(is_zero([0, 0, 0, 0, 0, 0, 0, 0]))
}

test "is_zero_array_size_16_zeros" {
  assert_true(is_zero([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))
}

test "is_zero_array_size_1_nonzero" {
  assert_false(is_zero([1]))
}

test "is_zero_array_size_2_one_nonzero" {
  assert_false(is_zero([0, 1]))
}

// Test hex encoding with single bytes
test "hex_single_byte_00" {
  assert_eq(bytes_to_hex([0x00]), "00")
}

test "hex_single_byte_FF" {
  assert_eq(bytes_to_hex([0xFF]), "ff")
}

test "hex_single_byte_AA" {
  assert_eq(bytes_to_hex([0xAA]), "aa")
}

test "hex_single_byte_55" {
  assert_eq(bytes_to_hex([0x55]), "55")
}

test "hex_two_bytes" {
  assert_eq(bytes_to_hex([0x12, 0x34]), "1234")
}

test "hex_three_bytes" {
  assert_eq(bytes_to_hex([0x12, 0x34, 0x56]), "123456")
}

test "hex_four_bytes" {
  assert_eq(bytes_to_hex([0x12, 0x34, 0x56, 0x78]), "12345678")
}

// Test context creation preserves input values
test "context_preserves_trace_id_values" {
  let original_trace_id = [0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0x00]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(original_trace_id, span_id, 0)
  
  assert_eq(ctx.trace_id_hex(), "aabbccddeeff112233445566778899" + "00")
}

test "context_preserves_span_id_values" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let original_span_id = [0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22]
  let ctx = span_context(trace_id, original_span_id, 0)
  
  assert_eq(ctx.span_id_hex(), "aabbccddeeff1122")
}

// Test trace_flags preservation
test "trace_flags_value_preserved_0x00" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x00)
  
  assert_eq(ctx.trace_flags, 0x00)
}

test "trace_flags_value_preserved_0xFF" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0xFF)
  
  assert_eq(ctx.trace_flags, 0xFF)
}

test "trace_flags_value_preserved_0x55" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x55)
  
  assert_eq(ctx.trace_flags, 0x55)
}
