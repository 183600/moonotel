// Enhanced edge case tests for OpenTelemetry Span Context
// Focus on boundary conditions, special values, and combination scenarios

// Test trace_id with various patterns
test "trace_id_all_ones" {
  let trace_id = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.trace_id_hex(), "ffffffffffffffffffffffffffffffff")
}

test "trace_id_alternating_bits" {
  let trace_id = [0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.trace_id_hex(), "aa55aa55aa55aa55aa55aa55aa55aa55")
}

test "trace_id_single_nonzero_byte_first" {
  let trace_id = [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "trace_id_single_nonzero_byte_last" {
  let trace_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "trace_id_single_nonzero_byte_middle" {
  let trace_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

// Test span_id with various patterns
test "span_id_all_ones" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.span_id_hex(), "ffffffffffffffff")
}

test "span_id_alternating_bits" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.span_id_hex(), "aa55aa55aa55aa55")
}

test "span_id_single_nonzero_byte_first" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "span_id_single_nonzero_byte_last" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "span_id_single_nonzero_byte_middle" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

// Test trace_flags combinations
test "trace_flags_max_value" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0xFF)
  assert_true(ctx.is_sampled())
}

test "trace_flags_even_values" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x02)
  assert_false(ctx.is_sampled())
}

test "trace_flags_multiple_bits_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x07)
  assert_true(ctx.is_sampled())
}

test "trace_flags_bit_pattern_10101010" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0xAA)
  assert_false(ctx.is_sampled())
}

test "trace_flags_bit_pattern_01010101" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x55)
  assert_true(ctx.is_sampled())
}

// Test hex encoding with special byte values
test "hex_encoding_boundary_0x00" {
  let bytes = [0x00]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "00")
}

test "hex_encoding_boundary_0x0F" {
  let bytes = [0x0F]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "0f")
}

test "hex_encoding_boundary_0xF0" {
  let bytes = [0xF0]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "f0")
}

test "hex_encoding_boundary_0xFF" {
  let bytes = [0xFF]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "ff")
}

test "hex_encoding_multiple_boundaries" {
  let bytes = [0x00, 0x0F, 0xF0, 0xFF]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "000ff0ff")
}

test "hex_encoding_all_hex_digits" {
  let bytes = [0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "0123456789abcdef")
}

// Test is_zero function with edge cases
test "is_zero_empty_array" {
  let bytes : Array[Int] = []
  assert_true(is_zero(bytes))
}

test "is_zero_single_zero" {
  let bytes = [0]
  assert_true(is_zero(bytes))
}

test "is_zero_single_nonzero" {
  let bytes = [1]
  assert_false(is_zero(bytes))
}

test "is_zero_long_array_all_zeros" {
  let bytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  assert_true(is_zero(bytes))
}

test "is_zero_long_array_last_nonzero" {
  let bytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
  assert_false(is_zero(bytes))
}

// Test invalid span contexts
test "invalid_context_trace_id_too_short" {
  let trace_id = [0x01, 0x02, 0x03]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

test "invalid_context_trace_id_too_long" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

test "invalid_context_span_id_too_short" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

test "invalid_context_span_id_too_long" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

test "invalid_context_both_ids_wrong_length" {
  let trace_id = [0x01, 0x02]
  let span_id = [0x01, 0x02, 0x03]
  let ctx = span_context(trace_id, span_id, 1)
  assert_false(ctx.is_valid())
}

// Test combination scenarios
test "sampled_with_all_max_values" {
  let trace_id = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  let span_id = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  let ctx = span_context(trace_id, span_id, 0xFF)
  assert_true(ctx.is_valid())
  assert_true(ctx.is_sampled())
}

test "not_sampled_with_all_max_values" {
  let trace_id = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  let span_id = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  let ctx = span_context(trace_id, span_id, 0xFE)
  assert_true(ctx.is_valid())
  assert_false(ctx.is_sampled())
}

// Test sequential patterns
test "trace_id_sequential_ascending" {
  let trace_id = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.trace_id_hex(), "000102030405060708090a0b0c0d0e0f")
}

test "trace_id_sequential_descending" {
  let trace_id = [0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "span_id_sequential_ascending" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.span_id_hex(), "0001020304050607")
}

test "span_id_sequential_descending" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x10]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

// Test repeating patterns
test "trace_id_repeating_pattern_01" {
  let trace_id = [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.trace_id_hex(), "01010101010101010101010101010101")
}

test "trace_id_repeating_pattern_AA" {
  let trace_id = [0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "span_id_repeating_pattern_01" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.span_id_hex(), "0101010101010101")
}

test "span_id_repeating_pattern_FF" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_eq(ctx.span_id_hex(), "ffffffffffffffff")
}

// Test byte_to_hex_char for all values
test "byte_to_hex_char_all_valid_values" {
  assert_eq(byte_to_hex_char(0), "0")
  assert_eq(byte_to_hex_char(1), "1")
  assert_eq(byte_to_hex_char(2), "2")
  assert_eq(byte_to_hex_char(3), "3")
  assert_eq(byte_to_hex_char(4), "4")
  assert_eq(byte_to_hex_char(5), "5")
  assert_eq(byte_to_hex_char(6), "6")
  assert_eq(byte_to_hex_char(7), "7")
  assert_eq(byte_to_hex_char(8), "8")
  assert_eq(byte_to_hex_char(9), "9")
  assert_eq(byte_to_hex_char(10), "a")
  assert_eq(byte_to_hex_char(11), "b")
  assert_eq(byte_to_hex_char(12), "c")
  assert_eq(byte_to_hex_char(13), "d")
  assert_eq(byte_to_hex_char(14), "e")
  assert_eq(byte_to_hex_char(15), "f")
}

test "byte_to_hex_char_invalid_value_16" {
  assert_eq(byte_to_hex_char(16), "0")
}

test "byte_to_hex_char_invalid_value_255" {
  assert_eq(byte_to_hex_char(255), "0")
}

test "byte_to_hex_char_invalid_negative" {
  assert_eq(byte_to_hex_char(-1), "0")
}

// Additional invalid span context tests
test "invalid_span_context_has_correct_properties" {
  let ctx = invalid_span_context()
  assert_false(ctx.is_valid())
  assert_false(ctx.is_sampled())
  assert_eq(ctx.trace_flags, 0)
}

test "invalid_span_context_trace_id_is_zero" {
  let ctx = invalid_span_context()
  assert_true(is_zero(ctx.trace_id))
}

test "invalid_span_context_span_id_is_zero" {
  let ctx = invalid_span_context()
  assert_true(is_zero(ctx.span_id))
}

test "invalid_span_context_hex_encoding" {
  let ctx = invalid_span_context()
  assert_eq(ctx.trace_id_hex(), "00000000000000000000000000000000")
  assert_eq(ctx.span_id_hex(), "0000000000000000")
}

// Test context with minimal valid values
test "minimal_valid_trace_id" {
  let trace_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]
  let span_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "minimal_valid_span_id" {
  let trace_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]
  let span_id = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

// Test specific bit patterns in trace_flags
test "trace_flags_only_bit_0_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x01)
  assert_true(ctx.is_sampled())
}

test "trace_flags_only_bit_1_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x02)
  assert_false(ctx.is_sampled())
}

test "trace_flags_only_bit_7_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x80)
  assert_false(ctx.is_sampled())
}

test "trace_flags_bits_0_and_7_set" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0x81)
  assert_true(ctx.is_sampled())
}

// Test edge cases with powers of 2
test "trace_id_powers_of_2" {
  let trace_id = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

test "span_id_powers_of_2" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
}

// Test mixed case scenarios
test "valid_context_with_zero_trace_flags" {
  let trace_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10]
  let span_id = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
  let ctx = span_context(trace_id, span_id, 0)
  assert_true(ctx.is_valid())
  assert_false(ctx.is_sampled())
}

test "hex_encoding_preserves_leading_zeros" {
  let bytes = [0x00, 0x01, 0x00, 0x0A]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "0001000a")
}

test "hex_encoding_preserves_trailing_zeros" {
  let bytes = [0x0A, 0x01, 0x00, 0x00]
  let hex = bytes_to_hex(bytes)
  assert_eq(hex, "0a010000")
}
